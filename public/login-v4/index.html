<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Login v4</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#164113" />
    <meta name="msapplication-TileColor" content="#006600" />
    <meta name="theme-color" content="#006600" />
  </head>
  <body></body>
  <script type="module">
    import {
      loop,
      start,
      never,
      input,
      mapE,
      filter,
      merge,
      mapTag,
      tag,
      observeE,
      output,
      switchE,
      stepper,
      mergeBind,
      getClicks,
      inputValues,
    } from "./chronomancy.js";
    const k = (x) => () => x;

    function* userDatabase({
      insertions,
      usernamesToRemove,
      clears,
      signupAttempts,
    }) {
      const internalTableB = yield loop;

      const protoFindUsername = (table, start, end, username) => {
        if (start === end) {
          return start;
        }
        const middle = Math.floor((start + end) / 2);
        if (table[middle].username < username) {
          return protoFindUsername(table, middle + 1, end, username);
        } else {
          return protoFindUsername(table, start, middle, username);
        }
      };
      const findUsername = (table, username) =>
        protoFindUsername(table, 0, table.length, username);

      const signups = filter(
        mapTag(signupAttempts, internalTableB, (user, table) => {
          const index = findUsername(table, user.username);
          const foundUser = table[index];
          if (foundUser === undefined || foundUser.username !== user.username) {
            return [index, user];
          }
          return null;
        }),
        (x) => x !== null
      );
      let tableTransform = mapE(
        signups,
        ([index, user]) =>
          (table) =>
            table.splice(index, 0, user)
      );

      insertions = mapTag(
        insertions,
        internalTableB,
        ({ username, password }, table) => {
          const index = findUsername(table, username);
          const foundUser = table[index];
          if (foundUser === undefined || foundUser.username !== username) {
            return ["createUser", index, { username, password }];
          }
          if (foundUser.password !== password) {
            return ["changePassword", index, password];
          }
          return [];
        }
      );
      const createUserInsertions = mapE(
        filter(insertions, (x) => x[0] === "createUser"),
        ([, index, user]) => [index, user]
      );
      tableTransform = merge(
        tableTransform,
        mapE(
          createUserInsertions,
          ([index, user]) =>
            (table) =>
              table.splice(index, 0, user)
        )
      );
      const createdUsers = merge(createUserInsertions, signups);
      const changePasswordInsertions = filter(
        insertions,
        (x) => x[0] === "changePassword"
      );
      const passwordChanges = mapTag(
        changePasswordInsertions,
        internalTableB,
        ([, index, password], table) => ({
          index,
          username: table[index].username,
          password,
        })
      );

      tableTransform = merge(
        tableTransform,
        mapE(
          passwordChanges,
          ({ index, password }) =>
            (table) =>
              (table[index].password = password)
        )
      );
      const removedUsers = mapTag(
        usernamesToRemove,
        internalTableB,
        (username, table) => ({
          index: findUsername(table, username),
          username,
        })
      );
      tableTransform = merge(
        tableTransform,
        mapE(
          removedUsers,
          ({ index }) =>
            (table) =>
              table.splice(index, 1)
        )
      );
      const tableLengthOnClear = mapE(
        tag(clears, internalTableB),
        (table) => table.length
      );
      clears = filter(tableLengthOnClear, (length) => length !== 0);
      tableTransform = merge(
        tableTransform,
        mapE(clears, () => (table) => (table.length = 0))
      );

      // TODO make a combinator for this use case.
      // The copy prevents side-effects if we want to access internalTableB arbitrarily.
      const newInternalTables = mapTag(
        tableTransform,
        internalTableB,
        (transform, table) => {
          const copy = [...table];
          transform(copy);
          return copy;
        }
      );
      internalTableB.loop(yield* stepper([], newInternalTables));

      const tryLogins = (event) =>
        mapTag(event, internalTableB, ({ username, password }, table) => {
          const foundUser = table[findUsername(table, username)];
          return (
            foundUser !== undefined &&
            foundUser.username === username &&
            foundUser.password === password
          );
        });
      return {
        createdUsers,
        passwordChanges,
        removedUsers,
        clears,
        tryLogins,
        signups,
      };
    }

    const nodeBuilder = (constructor, modifiers) => {
      const fromImpureBuilder = (impureBuild) => {
        const builder = (...children) =>
          fromImpureBuilder((varsOut) => {
            const node = impureBuild(varsOut);
            // Use append instead of appendChild because we need to handle text nodes
            node.append(
              ...children.map((child) => child._impureBuild(varsOut))
            );
            return node;
          });
        for (const [key, modifier] of Object.entries(modifiers)) {
          builder[key] = (...args) =>
            fromImpureBuilder((varsOut) => {
              const node = impureBuild(varsOut);
              modifier(...args)(node);
              return node;
            });
        }
        builder._impureBuild = impureBuild;
        builder.build = (_) => {
          const varsOut = {};
          varsOut.root = impureBuild(varsOut);
          return varsOut;
        };
        builder.var = (name) =>
          fromImpureBuilder((varsOut) => {
            const node = impureBuild(varsOut);
            varsOut[name] = node;
            return node;
          });
        return builder;
      };
      return fromImpureBuilder(constructor);
    };
    const div = nodeBuilder((_) => document.createElement("div"), {});
    const button = nodeBuilder((_) => document.createElement("button"), {
      textContent: (textContent) => (node) => (node.textContent = textContent),
    });
    const textInput = nodeBuilder((_) => {
      const node = document.createElement("input");
      node.type = "text";
      return node;
    }, {});
    const p = nodeBuilder((_) => document.createElement("p"), {});
    const table = nodeBuilder((_) => document.createElement("table"), {});
    const thead = nodeBuilder((_) => document.createElement("thead"), {});
    const tbody = nodeBuilder((_) => document.createElement("tbody"), {});
    const tr = nodeBuilder((_) => document.createElement("tr"), {});
    const th = nodeBuilder((_) => document.createElement("th"), {
      textContent: (textContent) => (node) => (node.textContent = textContent),
    });
    const td = nodeBuilder((_) => document.createElement("td"), {
      textContent: (textContent) => (node) => (node.textContent = textContent),
    });
    const text = (string) => ({
      _impureBuild: (_) => string,
    });

    function* userTable(signupAttempts) {
      const {
        root: userTableDiv,
        clearButton,
        userTable,
        usernameInsertInput,
        passwordInsertInput,
        insertButton,
        userTableBody,
      } = div(
        button.var("clearButton").textContent("Clear"),
        table.var("userTable")(
          thead(
            tr(th.textContent("Username"), th.textContent("Password")),
            tr(
              td(textInput.var("usernameInsertInput")),
              td(textInput.var("passwordInsertInput")),
              td(button.var("insertButton").textContent("Insert"))
            )
          ),
          tbody.var("userTableBody")
        )
      ).build();

      const insertions = filter(
        mapTag(
          tag(getClicks(insertButton), inputValues(usernameInsertInput)),
          inputValues(passwordInsertInput),
          (username, password) => ({
            username,
            password,
          })
        ),
        ({ username, password }) => username !== "" && password !== ""
      );

      const usernamesToRemove = yield loop;

      const { createdUsers, passwordChanges, removedUsers, clears, tryLogins } =
        yield* userDatabase({
          insertions,
          usernamesToRemove,
          clears: getClicks(clearButton),
          signupAttempts,
        });

      yield* output(insertions, () => {
        usernameInsertInput.value = "";
        passwordInsertInput.value = "";
      });

      // TODO make pure
      usernamesToRemove.loop(
        yield* mergeBind(createdUsers, ([index, user]) => {
          const { root: rowElement, xButton } = tr(
            td.textContent(user.username),
            td.textContent(user.password),
            td(button.var("xButton").textContent("X"))
          ).build();
          if (index === userTableBody.children.length) {
            userTableBody.appendChild(rowElement);
          } else {
            userTableBody.insertBefore(
              rowElement,
              userTableBody.children[index]
            );
          }
          return mapE(getClicks(xButton), (_) => user.username);
        })
      );

      yield* output(passwordChanges, ({ index, password }) => {
        const rowElement = userTableBody.children[index];
        rowElement.children[1].textContent = password;
      });

      yield* output(removedUsers, ({ index }) =>
        userTableBody.children[index].remove()
      );

      yield* output(clears, (_) => (userTableBody.innerHTML = ""));

      return { userTableDiv, passwordChanges, removedUsers, clears, tryLogins };
    }

    // Pull monad
    function* main() {
      const signupAttempts = yield loop;

      //div(yield* userTable(signupAttempts).var("userTable"), slot(loginDiv))
      const { userTableDiv, passwordChanges, removedUsers, clears, tryLogins } =
        yield* userTable(signupAttempts);
      document.body.appendChild(userTableDiv);

      function* createLoginDiv() {
        const {
          root,
          usernameInput,
          passwordInput,
          loginButton,
          statusText,
          signupButton,
        } = div(
          text("Username:"),
          textInput.var("usernameInput"),
          text("Password:"),
          textInput.var("passwordInput"),
          button.var("loginButton").textContent("Login"),
          p.var("statusText"),
          text("Don't have an account yet?"),
          button.var("signupButton").textContent("Signup")
        ).build();

        let loginAttempts = mapTag(
          tag(getClicks(loginButton), inputValues(usernameInput)),
          inputValues(passwordInput),
          (username, password) => ({
            username,
            password,
          })
        );
        yield* output(
          filter(loginAttempts, ({ username }) => username === ""),
          () => (statusText.textContent = "Username required!")
        );
        yield* output(
          filter(
            loginAttempts,
            ({ username, password }) => username !== "" && password === ""
          ),
          () => (statusText.textContent = "Password required!")
        );
        loginAttempts = tryLogins(
          filter(
            loginAttempts,
            ({ username, password }) => username !== "" && password !== ""
          )
        );
        yield* output(
          filter(loginAttempts, (success) => !success),
          () => (statusText.textContent = `Invalid login!`)
        );

        return [
          root,
          merge(
            mapE(getClicks(signupButton), k(createSignupDiv)),
            mapE(
              tag(
                filter(loginAttempts, (success) => success),
                inputValues(usernameInput)
              ),
              (username) => () => createLoggedInDiv(username)
            )
          ),
          never,
        ];
      }

      function* createSignupDiv() {
        const {
          root,
          usernameInput,
          passwordInput,
          signupButton,
          statusText,
          loginButton,
        } = div(
          text("Username:"),
          textInput.var("usernameInput"),
          text("Password:"),
          textInput.var("passwordInput"),
          button.var("signupButton").textContent("Signup"),
          p.var("statusText"),
          text("Already have an account?"),
          button.var("loginButton").textContent("Login")
        ).build();

        let signupAttempts = mapTag(
          tag(getClicks(signupButton), inputValues(usernameInput)),
          inputValues(passwordInput),
          (username, password) => ({
            username,
            password,
          })
        );
        yield* output(
          filter(signupAttempts, ({ username }) => username === ""),
          () => (statusText.textContent = "Username required!")
        );
        yield* output(
          filter(
            signupAttempts,
            ({ username, password }) => username !== "" && password === ""
          ),
          () => (statusText.textContent = "Password required!")
        );
        signupAttempts = filter(
          signupAttempts,
          ({ username, password }) => username !== "" && password !== ""
        );

        return [
          root,
          merge(
            mapE(getClicks(loginButton), k(createLoginDiv)),
            mapE(
              signupAttempts,
              ({ username }) =>
                () =>
                  createLoggedInDiv(username)
            )
          ),
          signupAttempts,
        ];
      }

      function* createLoggedInDiv(username) {
        const { root: loggedInDiv, logoutButton } = div(
          text(`Hello ${username}`),
          button.var("logoutButton").textContent("Logout")
        ).build();

        return [
          loggedInDiv,
          mapE(
            merge(
              filter(
                merge(passwordChanges, removedUsers),
                (x) => x.username === username
              ),
              merge(getClicks(logoutButton), clears)
            ),
            k(createLoginDiv)
          ),
          never,
        ];
      }

      let publishStartPage;
      const startPage = input((p) => {
        publishStartPage = p;
        return () => {};
      });
      const publishLoginDiv = (_) => publishStartPage(createLoginDiv);

      const authPages = yield loop;
      const appPages = observeE(merge(authPages, startPage));

      yield* output(appPages, ([appDiv, ,]) => {
        document.getElementById("appPage")?.remove();
        appDiv.id = "appPage";
        document.body.appendChild(appDiv);
      });

      signupAttempts.loop(
        yield* switchE(mapE(appPages, ([, , signupAttempts]) => signupAttempts))
      );
      authPages.loop(
        yield* switchE(mapE(appPages, ([, nextAuthPage]) => nextAuthPage))
      );

      return publishLoginDiv;
    }

    start(main)();
  </script>
</html>
