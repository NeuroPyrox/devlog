<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Login v4</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#164113" />
    <meta name="msapplication-TileColor" content="#006600" />
    <meta name="theme-color" content="#006600" />
  </head>
  <body></body>
  <script>
    // TODO learn how imports work so I can use a library instead of this custom implementation.
    class PriorityQueue {
      constructor() {
        this._array = [];
      }

      push(value) {
        const index = this._array.length;
        // Special cases of the loop below, so we can avoid writing this._array.push(null)
        if (index === 0) {
          this._array.push(value);
          return;
        } else {
          const parentIndex = Math.floor((index - 1) / 2);
          const parent = this._array[parentIndex];
          if (parent.priority <= value.priority) {
            this._array.push(value);
            return;
          }
          this._array.push(parent);
          index = parentIndex;
        }

        // This is where the real logic is
        while (0 < index) {
          const parentIndex = Math.floor((index - 1) / 2);
          const parent = this._array[parentIndex];

          if (parent.priority <= value.priority) break;

          this._array[index] = parent;
          index = parentIndex;
        }

        this._array[index] = value;
      }

      next() {
        switch (this._array.length) {
          case 0:
            return { done: true };
          case 1:
            return {
              value: this._array.pop(),
              done: false
            };
        }
        const value = this._array[0];

        const index = 0;
        const end = this._array.pop();

        while (true) {
          const swapIndex = index;
          const swap = end;

          // swap = min(swap, leftChild)
          const leftIndex = 2 * index + 1;
          const leftChild = this._array[leftIndex];
          if (leftChild && leftChild.priority < swap.priority) {
            swapIndex = leftIndex;
            swap = leftChild;
          }

          // swap = min(swap, rightChild)
          const rightIndex = leftIndex + 1;
          const rightChild = this._array[rightIndex];
          if (rightChild && rightChild.priority < swap.priority) {
            swapIndex = rightIndex;
            swap = rightChild;
          }

          if (swapIndex === index) break;
          this._array[index] = swap;
          index = swapIndex;
        }

        this._array[index] = end;
        return { value, done: false };
      }

      [Symbol.iterator]() {
        return this;
      }
    }

    class PublishContext {
      constructor() {
        this._values = new WeakMap();
        this._dependencies = [];
        this._actions = [];
      }

      read(publisher) {
        return this._values.get(publisher);
      }

      write(publisher, value) {
        this._values.set(publisher, value);
      }

      // Parent and child are both publishers
      queueAddChild(parent, child) {
        this._dependencies.push([parent, child]);
      }
      
      queueAction(action) {
        this._actions.push(action);
      }
    }

    class Output {
      static isHot = true;

      constructor(publisher, makeAction) {
        this._publisher = publisher;
        this._makeAction = makeAction;
        this.priority = 0;
      }

      // Publish monad
      *poll() {
        // value !== undefined
        const value = yield this._publisher.read();
        // Mutable: context
        yield context => context.queueAction(this._makeAction(value));
        return [];
      }
    }

    // We separate this from Subscriber to allow for garbage collection.
    // All the strong references to this are from:
    // - Parent publishers
    // - External event listeners (via inputSubscriber)
    // - Children publishers that only have one parent
    // This is dead when:
    //   ((its parents are dead) and (its external event listeners are dead))
    //   or ((it has no children) and (its Subscriber is dead))
    class Publisher {
      constructor(poll) {
        this._poll = poll;
        this._children = [];
        this.isHot = false;
        this.priority = 0;
      }

      // Publish monad
      *poll() {
        const value = yield* this._poll();
        if (value === undefined) return [];
        yield this.write(value);
        return this._children.filter(
          child => child.isHot && this.priority < child.priority
        );
      }

      // Publish monad
      // Instead of storing the current value as a variable,
      // we store it in the monadic Publish context,
      // so we can easily delete every Publisher's value once the changes get flushed.
      read() {
        return context => context.read(this);
      }

      // Publish monad
      // Mutable: context
      write(value) {
        return context => context.write(this, value);
      }

      // Subscribe monad
      // Mutable: context
      queueAddChild(child) {
        return context => context.queueAddChild(this, child);
      }

      removeChild(child) {
        // TODO
      }

      onSubscriberDeath() {
        // TODO
      }
    }

    // Publish monad
    function* readWeakPublisher(weak) {
      publisher = weak.deref();
      if (publisher === undefined) {
        return undefined;
      } else {
        return yield publisher.read();
      }
    }

    // We separate this from Publisher to allow for garbage collection.
    // When this dies, it means no more children can be added to its Publisher instance.
    class Subscriber {
      // Mutable: publisher
      static _finalizers = new FinalizationRegistry(weakPublisher => {
        const publisher = weakPublisher.deref();
        if (publisher !== undefined) {
          publisher.onSubscriberDeath();
        }
      });

      // TODO change parameters
      // poll is in the Publish monad
      constructor(poll) {
        this._publisher = new WeakRef(new Publisher(poll));
        _finalizers.register(this, this._publisher);
      }

      // Subscribe monad
      // Mutable: publisher
      *subscribe(makeAction) {
        const parent = this._publisher.deref();
        if (parent === undefined) return () => {};

        const output = new Output(parent, makeAction);

        yield parent.queueAddChild(output);
        const unsubscribe = parent.removeChild(output);
        return unsubscribe;
      }

      // Subscribe monad
      *map(f) {
        const parent = this._publisher.deref();
        if (parent === undefined) return never;

        // TODO test what "this" is
        // TODO unsubscribe
        const [publisher, subscriber] = newPubSub(function*() {
          // yield parent.read() !== undefined;
          return f(yield parent.read());
        });

        yield parent.queueAddChild(publisher);
        return subscriber;
      }

      // Subscribe monad
      *filter(predicate) {
        const parent = this._publisher.deref();
        if (parent === undefined) return never;

        const [publisher, subscriber] = newPubSub(function*() {
          // value !== undefined
          const value = yield parent.read();
          return predicate(value) ? value : undefined;
        });

        yield parent.queueAddChild(publisher);
        return subscriber;
      }

      // Subscribe monad
      *merge(other, simultaneous = (a, b) => a) {
        // Don't hold references to this or other inside the generator
        const weakA = this._publisher;
        const weakB = other._publisher;
        
        const [publisher, subscriber] = newPubSub(function*() {
          const a = yield* readWeakPublisher(weakA);
          const b = yield* readWeakPublisher(weakB);
          if (a === undefined) return b;
          if (b === undefined) return a;
          return simultaneous(a, b);
        });

        yield* this.queueAddChild(publisher);
        yield* other.queueAddChild(publisher);
        return subscriber;
      }

      // Subscribe monad
      *queueAddChild(child) {
        const publisher = this._publisher.deref();
        if (publisher !== undefined) {
          yield publisher.queueAddChild(child);
        }
      }
    }

    // TODO handle onUnpollable
    const newPubSub = (poll, onUnpollable) => {
      const publisher = new Publisher(poll);
      const subscriber = new Subscriber(publisher);
      return [publisher, subscriber];
    };

    // Mutable: generator, context
    const runPublishMonad = generator => {
      let step = generator.next();
      const context = new PublishContext();
      while (!step.done) {
        step = generator.next(step.value(context));
      }
      // TODO handle context._dependencies
    };

    // Publish monad
    // Mutable: queue
    function* publish(publisher, value) {
      yield publisher.write(value);
      const queue = new PriorityQueue();
      queue.push(publisher);
      for (const pollable of queue) {
        const childrenToPoll = yield* pollable.poll();
        for (const child of childrenToPoll) {
          // Yes, I'm mutating the queue while iterating over it.
          queue.push(child);
        }
      }
    }

    // Subscribe monad
    // Impure: subscribe, runEvalPulses
    // Subscribe takes a handler function, attaches it as an event listener,
    // and returns an unsubscribe function.
    // The closures shouldn't keep pulsePull alive.
    function* inputSubscriber(subscribe) {
      const [publisher, subscriber] = newPubSub(function*() {
        return yield publisher.read();
      }, subscribe(x => runPublishMonad(publish(publisher, x))));
      return subscriber;
    }

    // TODO
    const never = undefined;

    // TODO separate layers of abstraction
    const userDatabase = ({
      insertions,
      usernamesToRemove,
      clears,
      signupAttempts
    }) => {
      let internalTable = [];

      const protoFindUsername = (start, end, username) => {
        if (start === end) {
          return start;
        }
        const middle = Math.floor((start + end) / 2);
        if (internalTable[middle].username < username) {
          return protoFindUsername(middle + 1, end, username);
        } else {
          return protoFindUsername(start, middle, username);
        }
      };
      const findUsername = username =>
        protoFindUsername(0, internalTable.length, username);

      let signups = signupAttempts
        .map(user => {
          const index = findUsername(user.username);
          const foundUser = internalTable[index];
          if (foundUser === undefined || foundUser.username !== user.username) {
            internalTable.splice(index, 0, user);
            return [index, user];
          }
          return null;
        })
        .filter(x => x !== null);

      insertions = insertions.map(({ username, password }) => {
        const index = findUsername(username);
        const foundUser = internalTable[index];
        if (foundUser === undefined || foundUser.username !== username) {
          return ["createUser", index, { username, password }];
        }
        if (foundUser.password !== password) {
          return ["changePassword", index, password];
        }
        return [];
      });
      const createdUsers = insertions
        .filter(x => x[0] === "createUser")
        .map(([, index, user]) => {
          internalTable.splice(index, 0, user);
          return [index, user];
        })
        .merge(signups);
      const passwordChanges = insertions
        .filter(x => x[0] === "changePassword")
        .map(([, index, password]) => {
          const user = internalTable[index];
          user.password = password;
          const { username } = user;
          return { index, username, password };
        });

      const removedUsers = usernamesToRemove.map(username => {
        const index = findUsername(username);
        internalTable.splice(index, 1);
        return { index, username };
      });
      clears = clears.filter(_ => internalTable.length !== 0);
      clears.map(_ => (internalTable = []));

      signups = signups.map(([, { username }]) => username);

      const tryLogins = stream =>
        stream.map(({ username, password }) => {
          const foundUser = internalTable[findUsername(username)];
          return (
            foundUser !== undefined &&
            foundUser.username === username &&
            foundUser.password === password
          );
        });
      return {
        createdUsers,
        passwordChanges,
        removedUsers,
        clears,
        tryLogins,
        signups
      };
    };

    // These next 3 functions are part of _InnerEvent,
    // but I factored them out because I'm paranoid of
    // accidentally capturing "this" as a strong reference
    function _unsubscribeHandler(weakThat, weakHandle) {
      return _ => {
        const that = weakThat.deref();
        const handle = weakHandle.deref();
        if (that === undefined) {
          return;
        }

        const index = that._findHandle(handle);
        that._changeNumHotHandlers(-that.handlers[index][1]);
        that._handlers.splice(index, 1);

        if (that._isDead()) {
          that._wrapperFinalizers.unregister(that);
          that._unsubscribe();
        }
      };
    }
    function _setHandlerHotness(weakThat, weakHandle) {
      return isHot => {
        const that = weakThat.deref();
        const handle = weakHandle.deref();
        if (that === undefined) {
          return;
        }

        const index = that._findHandle(handle);
        that._changeNumHotHandlers(isHot - that._handlers[index][1]);
        that._handlers[index][1] = isHot;
      };
    }
    function _publish(that) {
      return x => {
        if (that._isDead()) {
          that._wrapperFinalizers.unregister(that);
          that._unsubscribe();
        } else {
          // Actual non-cleanup logic
          for (const [handle, isHot] of that._handlers) {
            if (isHot) {
              handle(x);
            }
          }
        }
      };
    }

    // This is a very complex class heavy with resource management,
    // but rest assured its interface is simple
    class _InnerEvent {
      // Triggers to call unsubscribe:
      // - [handler] gets unsubscribed then _isDead()
      // - [publish] a value when _isDead() (redundant, but may be earlier than the wrapper trigger)
      // - [wrapper] gets finalized when _isDead()
      // How all of these triggers cut off the other ones:
      // - _isDead() implies the [handler] trigger is cut off
      // - _unsubscribe() (contractually) cuts off the [publish] trigger
      // - _wrapperFinalizers.unregister cuts off the [wrapper] trigger
      // _unsubscribe is guaranteed to be called once _isDead() becomes true in all cases:
      // - If #wrapper.deref() became undefined, then the [wrapper] trigger will soon follow
      // - If _handlers.length became 0, then the [handler] trigger will immediately follow
      // - _isDead() couldn't have started out true because #wrapper starts off non-empty
      _unsubscribe;

      _handlers = []; // TODO optimize by using a linked list
      #setHotness;
      #numHotHandlers = 0;
      #wrapper;

      static _wrapperFinalizers = new FinalizationRegistry(weakThat => {
        const that = weakThat.deref();
        if (that !== undefined && that._handlers.length === 0) {
          // that._isDead() is implicitly true
          that._unsubscribe();
        }
      });

      constructor(subscribe, wrapper) {
        this.#wrapper = new WeakRef(wrapper);
        // VERY IMPORTANT: subscribe(_publish(this)) is the only way a strong reference to this gets exposed
        // That way, this can be garbage collected as soon as _publish(this) gets garbage collected
        [this._unsubscribe, this.#setHotness] = subscribe(_publish(this));
        this._wrapperFinalizers.register(wrapper, new WeakRef(this), this);
      }

      _isDead() {
        return (
          this.#wrapper.deref() === undefined && this._handlers.length === 0
        );
      }

      _findHandle(handle) {
        const index = this._handlers.findIndex(
          ([, foundHandle]) => foundHandle === handle
        );
        if (index === -1) {
          // Treat this as an error because it indicates brittle logic elsewhere
          throw "Can't find handler";
        }
        return index;
      }

      // Triggers to call:
      // - subscribe a handler
      // - unsubscribe a handler
      // - set hotness of a handler
      // All callsites currently coerce a bool into an int
      // This method can never be called after _unsubscribe
      _changeNumHotHandlers(increment) {
        const oldHotness = this.#numHotHandlers === 0;
        this.#numHotHandlers += increment;
        const newHotness = this.#numHotHandlers === 0;
        if (oldHotness !== newHotness) {
          this.#setHotness(newHotness);
        }
      }

      subscribe(handle, isHot) {
        this._changeNumHotHandlers(isHot);
        this._handlers.push([handle, isHot]);

        // With weak references, the memory graph is a DAG
        // With strong references, each edge in the memory graph would become invertable,
        // so any endpoint subscription would prevent all garbage collection
        // In theory you only sometimes need the references to be weak,
        // but that would introduce unnecessary complexity compared to always making them weak
        const weakThis = new WeakRef(this);
        const weakHandle = new WeakRef(handle);
        return [
          _unsubscribeHandler(weakThis, weakHandle),
          _setHandlerHotness(weakThis, weakHandle)
        ];
      }
    }

    class Event {
      #inner;

      // Similar to the promise constructor
      // In the promise constructor, you pass a resolve function into the input,
      // whereas here you pass a publish function into the input
      // Subscribe also must return an unsubscribe callback that prevents any more values from being published,
      // and a setHotness callback that temporarily changes whether values get published
      // In order for garbage collection to take place,
      // the callbacks returned from subscribe can't strongly reference the publish function
      constructor(subscribe) {
        this.#inner = new WeakRef(new _InnerEvent(subscribe, this));
      }

      // Returns an unsubscribe function that you must call to allow garbage collection
      // Only call when creating a new abstraction
      _subscribe(handle, isHot) {
        const inner = this.#inner.deref();
        return inner === undefined
          ? [_ => {}, _ => {}]
          : inner.subscribe(handle, isHot);
      }

      // The return value of this._subscribe is extremely important for resource management
      #wrapPublish(publishWrapper) {
        return new Event(publish =>
          this._subscribe(publishWrapper(publish), false)
        );
      }

      map(f) {
        return this.#wrapPublish(publish => x => publish(f(x)));
      }

      filter(predicate) {
        return this.#wrapPublish(publish => x => {
          if (predicate(x)) {
            publish(x);
          }
        });
      }

      tag(get) {
        return this.#wrapPublish(publish => x => publish(get()));
      }

      mapTag(get, f) {
        return this.#wrapPublish(publish => x => publish(f(x, get())));
      }

      merge(other) {
        return new Event(publish => {
          const [thisUnsubscribe, thisSetHotness] = this._subscribe(
            publish,
            false
          );
          const [otherUnsubscribe, otherSetHotness] = other._subscribe(
            publish,
            false
          );
          return [
            _ => {
              thisUnsubscribe();
              otherUnsubscribe();
            },
            isHot => {
              thisSetHotness(isHot);
              otherSetHotness(isHot);
            }
          ];
        });
      }

      mergeBind(f) {
        return new Event(publish => {
          const unsubscribers = [];
          const hotnessSetters = [];
          unsubscribers.push(
            this._subscribe(x => {
              const [unsubscribe, setHotness] = f(x)._subscribe(publish);
              unsubscribers.push(unsubscribe);
              hotnessSetters.push(setHotness);
            }, true)[0]
          );
          return [
            _ => unsubscribers.map(x => x()),
            isHot => hotnessSetters.map(x => x(isHot))
          ];
        });
      }

      bind(f) {}
    }

    // This implementation creates memory leaks.
    // I'm not fixing it yet because the interface is unstable and it's still not even a performance bottleneck.
    const startEvents = subscribe => {
      const handlers = [];
      // Only call subscribe once so we don't have to keep recomputing x, such as in map
      subscribe(x => {
        for (const handle of handlers) {
          handle(x);
        }
      });
      // In startHandler, think of f as a wrapper for publish
      // If js was typed, publish would have the same type as f(publish)
      const startHandler = f =>
        startEvents(publish => handlers.push(f(publish)));
      return {
        map: f => startHandler(publish => x => publish(f(x))),
        filter: predicate =>
          startHandler(publish => x => {
            if (predicate(x)) {
              publish(x);
            }
          }),
        tag: get => startHandler(publish => _ => publish(get())),
        mapTag: (get, f) => startHandler(publish => x => publish(f(x, get()))),
        merge: other =>
          startHandler(publish => {
            other.map(publish);
            return publish;
          }),
        mergeBind: f => startHandler(publish => x => f(x).map(publish)),
        bind: f =>
          startHandler(publish => {
            let finish = _ => {};
            return x => {
              finish();
              let done = false;
              f(x)
                .filter(_ => !done)
                .map(publish);
              finish = _ => (done = true);
            };
          })
      };
    };
    const once = events =>
      startEvents(publish => {
        let done = false;
        events
          .filter(_ => !done)
          .map(x => {
            publish(x);
            done = true;
          });
      });
    const never = startEvents(_ => {});
    // Use addEventListener because using onclick could cancel other handlers
    const getClicks = button =>
      startEvents(publish =>
        button.addEventListener("click", _ => publish(null))
      );
    const getInputValues = inputElement => _ => inputElement.value;

    const recurseEvents = f => {
      let publish;
      const preEvents = startEvents(p => (publish = p));
      const [postEvents, result] = f(preEvents);
      postEvents.map(publish);
      return result;
    };

    const recurse2Events = f => {
      let publishA;
      let publishB;
      const preEventsA = startEvents(p => (publishA = p));
      const preEventsB = startEvents(p => (publishB = p));
      const [postEventsA, postEventsB, result] = f(preEventsA, preEventsB);
      postEventsA.map(publishA);
      postEventsB.map(publishB);
      return result;
    };

    const nodeBuilder = (constructor, modifiers) => {
      const fromImpureBuilder = impureBuild => {
        const builder = (...children) =>
          fromImpureBuilder(varsOut => {
            const node = impureBuild(varsOut);
            // Use append instead of appendChild because we need to handle text nodes
            node.append(...children.map(child => child._impureBuild(varsOut)));
            return node;
          });
        for (const [key, modifier] of Object.entries(modifiers)) {
          builder[key] = (...args) =>
            fromImpureBuilder(varsOut => {
              const node = impureBuild(varsOut);
              modifier(...args)(node);
              return node;
            });
        }
        builder._impureBuild = impureBuild;
        builder.build = _ => {
          const varsOut = {};
          varsOut.root = impureBuild(varsOut);
          return varsOut;
        };
        builder.var = name =>
          fromImpureBuilder(varsOut => {
            const node = impureBuild(varsOut);
            varsOut[name] = node;
            return node;
          });
        return builder;
      };
      return fromImpureBuilder(constructor);
    };
    const div = nodeBuilder(_ => document.createElement("div"), {});
    const button = nodeBuilder(_ => document.createElement("button"), {
      textContent: textContent => node => (node.textContent = textContent)
    });
    const textInput = nodeBuilder(_ => {
      const node = document.createElement("input");
      node.type = "text";
      return node;
    }, {});
    const p = nodeBuilder(_ => document.createElement("p"), {});
    const table = nodeBuilder(_ => document.createElement("table"), {});
    const thead = nodeBuilder(_ => document.createElement("thead"), {});
    const tbody = nodeBuilder(_ => document.createElement("tbody"), {});
    const tr = nodeBuilder(_ => document.createElement("tr"), {});
    const th = nodeBuilder(_ => document.createElement("th"), {
      textContent: textContent => node => (node.textContent = textContent)
    });
    const td = nodeBuilder(_ => document.createElement("td"), {
      textContent: textContent => node => (node.textContent = textContent)
    });
    const text = string => ({
      _impureBuild: _ => string
    });

    const userTable = signupAttempts =>
      recurseEvents(usernamesToRemove => {
        const {
          root: userTableDiv,
          clearButton,
          userTable,
          usernameInsertInput,
          passwordInsertInput,
          insertButton,
          userTableBody
        } = div(
          button.var("clearButton").textContent("Clear"),
          table.var("userTable")(
            thead(
              tr(th.textContent("Username"), th.textContent("Password")),
              tr(
                td(textInput.var("usernameInsertInput")),
                td(textInput.var("passwordInsertInput")),
                td(button.var("insertButton").textContent("Insert"))
              )
            ),
            tbody.var("userTableBody")
          )
        ).build();

        const insertions = getClicks(insertButton)
          .tag(getInputValues(usernameInsertInput))
          .mapTag(
            getInputValues(passwordInsertInput),
            (username, password) => ({
              username,
              password
            })
          )
          .filter(
            ({ username, password }) => username !== "" && password !== ""
          );

        const {
          createdUsers,
          passwordChanges,
          removedUsers,
          clears,
          tryLogins
        } = userDatabase({
          insertions,
          usernamesToRemove,
          clears: getClicks(clearButton),
          signupAttempts
        });

        insertions.map(_ => {
          usernameInsertInput.value = "";
          passwordInsertInput.value = "";
        });

        usernamesToRemove = createdUsers.mergeBind(([index, user]) => {
          const { root: rowElement, xButton } = tr(
            td.textContent(user.username),
            td.textContent(user.password),
            td(button.var("xButton").textContent("X"))
          ).build();
          if (index === userTableBody.children.length) {
            userTableBody.appendChild(rowElement);
          } else {
            userTableBody.insertBefore(
              rowElement,
              userTableBody.children[index]
            );
          }
          return getClicks(xButton).map(_ => user.username);
        });

        passwordChanges.map(({ index, password }) => {
          const rowElement = userTableBody.children[index];
          rowElement.children[1].textContent = password;
        });

        removedUsers.map(({ index }) => userTableBody.children[index].remove());

        clears.map(_ => (userTableBody.innerHTML = ""));

        return [
          usernamesToRemove,
          { userTableDiv, passwordChanges, removedUsers, clears, tryLogins }
        ];
      });

    const start = recurse2Events((signupAttempts, authPages) => {
      //div(userTable(signupAttempts).var("userTable"), slot(loginDiv))
      const {
        userTableDiv,
        passwordChanges,
        removedUsers,
        clears,
        tryLogins
      } = userTable(signupAttempts);
      document.body.appendChild(userTableDiv);
      document.body.appendChild(document.createElement("p"));

      const createLoginDiv = _ => {
        const {
          root,
          usernameInput,
          passwordInput,
          loginButton,
          statusText,
          signupButton
        } = div(
          text("Username:"),
          textInput.var("usernameInput"),
          text("Password:"),
          textInput.var("passwordInput"),
          button.var("loginButton").textContent("Login"),
          p.var("statusText"),
          text("Don't have an account yet?"),
          button.var("signupButton").textContent("Signup")
        ).build();

        let loginAttempts = getClicks(loginButton)
          .tag(getInputValues(usernameInput))
          .mapTag(getInputValues(passwordInput), (username, password) => ({
            username,
            password
          }));
        loginAttempts
          .filter(({ username }) => username === "")
          .map(_ => (statusText.textContent = "Username required!"));
        loginAttempts
          .filter(
            ({ username, password }) => username !== "" && password === ""
          )
          .map(_ => (statusText.textContent = "Password required!"));
        loginAttempts = tryLogins(
          loginAttempts.filter(
            ({ username, password }) => username !== "" && password !== ""
          )
        );
        loginAttempts
          .filter(success => !success)
          .map(_ => (statusText.textContent = `Invalid login!`));

        return [
          root,
          loginAttempts
            .filter(success => success)
            .tag(getInputValues(usernameInput))
            .map(createLoggedInDiv)
            .merge(getClicks(signupButton).map(createSignupDiv)),
          never
        ];
      };

      const createSignupDiv = _ => {
        const {
          root,
          usernameInput,
          passwordInput,
          signupButton,
          statusText,
          loginButton
        } = div(
          text("Username:"),
          textInput.var("usernameInput"),
          text("Password:"),
          textInput.var("passwordInput"),
          button.var("signupButton").textContent("Signup"),
          p.var("statusText"),
          text("Already have an account?"),
          button.var("loginButton").textContent("Login")
        ).build();

        const signupAttempts = getClicks(signupButton)
          .tag(getInputValues(usernameInput))
          .mapTag(getInputValues(passwordInput), (username, password) => ({
            username,
            password
          }));
        signupAttempts
          .filter(({ username }) => username === "")
          .map(_ => (statusText.textContent = "Username required!"));
        signupAttempts
          .filter(
            ({ username, password }) => username !== "" && password === ""
          )
          .map(_ => (statusText.textContent = "Password required!"));

        return [
          root,
          getClicks(loginButton).map(createLoginDiv),
          signupAttempts.filter(
            ({ username, password }) => username !== "" && password !== ""
          )
        ];
      };

      const createLoggedInDiv = username => {
        const { root: loggedInDiv, logoutButton } = div(
          text(`Hello ${username}`),
          button.var("logoutButton").textContent("Logout")
        ).build();

        return [
          loggedInDiv,
          getClicks(logoutButton)
            .merge(
              passwordChanges
                .merge(removedUsers)
                .filter(x => x.username === username)
            )
            .merge(clears)
            .map(createLoginDiv),
          never
        ];
      };

      let publishStartPage;
      const startPage = startEvents(p => (publishStartPage = p));
      const start = _ => publishStartPage(createLoginDiv());

      const appPages = authPages.merge(startPage);

      appPages.map(([appDiv, ,]) => {
        document.body.lastElementChild.remove();
        document.body.appendChild(appDiv);
      });

      return [
        appPages.bind(([, , signupAttempts]) => signupAttempts),
        appPages.bind(([, nextAuthPage]) => nextAuthPage),
        start
      ];
    });

    start();
  </script>
</html>
