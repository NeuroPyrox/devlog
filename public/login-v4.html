<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Login v4</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#164113" />
    <meta name="msapplication-TileColor" content="#006600" />
    <meta name="theme-color" content="#006600" />
  </head>
  <body></body>
  <script>
    // TODO learn how imports work so I can use a library instead of this custom implementation.
    class PriorityQueue {
      constructor() {
        this._array = [];
      }

      push(value) {
        const index = this._array.length;
        // Special cases of the loop below, so we can avoid writing this._array.push(null)
        if (index === 0) {
          this._array.push(value);
          return;
        } else {
          const parentIndex = Math.floor((index - 1) / 2);
          const parent = this._array[parentIndex];
          if (parent.priority <= value.priority) {
            this._array.push(value);
            return;
          }
          this._array.push(parent);
          index = parentIndex;
        }

        // This is where the real logic is
        while (0 < index) {
          const parentIndex = Math.floor((index - 1) / 2);
          const parent = this._array[parentIndex];

          if (parent.priority <= value.priority) break;

          this._array[index] = parent;
          index = parentIndex;
        }

        this._array[index] = value;
      }

      next() {
        switch (this._array.length) {
          case 0:
            return { done: true };
          case 1:
            return {
              value: this._array.pop(),
              done: false
            };
        }
        const value = this._array[0];

        const index = 0;
        const end = this._array.pop();

        while (true) {
          const swapIndex = index;
          const swap = end;

          // swap = min(swap, leftChild)
          const leftIndex = 2 * index + 1;
          const leftChild = this._array[leftIndex];
          if (leftChild && leftChild.priority < swap.priority) {
            swapIndex = leftIndex;
            swap = leftChild;
          }

          // swap = min(swap, rightChild)
          const rightIndex = leftIndex + 1;
          const rightChild = this._array[rightIndex];
          if (rightChild && rightChild.priority < swap.priority) {
            swapIndex = rightIndex;
            swap = rightChild;
          }

          if (swapIndex === index) break;
          this._array[index] = swap;
          index = swapIndex;
        }

        this._array[index] = end;
        return { value, done: false };
      }

      [Symbol.iterator]() {
        return this;
      }
    }

    const weakMapFromEdges = edges => {
      const graph = new WeakMap();
      for (const [parent, child] of edges) {
        const children = graph.get(parent);
        if (children === undefined) {
          graph.set(parent, [child]);
        } else {
          children.push(child);
        }
      }
      return graph;
    };

    class PullContext {
      constructor() {
        this._pulseGraphEdges = [];
        this._pulseGraphRootEdges = [];
      }

      // The [parentSinkSlot] is a wrapper around the child,
      // and you get the child via [parentSinkSlot.getPulseSource()].
      addPulseGraphEdge(parentSource, parentSinkSlot) {
        if (!parentSource.isBuilt()) {
          this._pulseGraphEdges.push([parentSource, parentSinkSlot]);
          return;
        }
        const parentSink = parentSource.getSink();
        if (parentSink !== undefined) {
          this._pulseGraphRootEdges.push([parentSink, parentSinkSlot]);
        }
        // TODO use profiler to tell which implementation to use.
        // Alternate implementation:
        //   const parentSink = parentSource.getSink();
        //   if (parentSink !== undefined) {
        //     this._pulseGraphRootEdges.push([parentSink, parentSinkSlot]);
        //   } else {
        //     this._pulseGraphEdges.push([parentSource, parentSinkSlot]);
        //   }
      }

      // Should only be called from runPull
      _flushChanges() {
        // [parent.getPulseSource()] is used for [LoopPulseSource].
        const graph = weakMapFromEdges(
          this._pulseGraphEdges.map(([parent, parentSinkSlot]) => [
            parent.getPulseSource(),
            parentSinkSlot
          ])
        );
        // Topological sort
        const sortedSinks = [];
        const visitedChildren = new WeakSet();
        const visit = (parentSource, parentSink) => {
          const parentSinkSlots = graph.get(parentSource) ?? [];
          // Before the for loop: DFS over each graph vertex [parentSource].
          // Inside the for loop: DFS over each graph edge [parentSource, childSource].
          // After the for loop: topological ordering of each graph vertex [parentSource].
          for (const parentSinkSlot of parentSinkSlots) {
            // Besides the error condition,
            // [parentSinkSlot.setParent(parentSink)] will get called once per iteration,
            // right before visiting the child (in DFS order),
            // but algorithmic magic prevents from putting that line of code here.
            
            if (parentSinkSlot.hasSingleParent()) {
              // This branch is redundant, but it's included as a performance optimization,
              // because you can omit the visitation checks if there's only one parent.
              // Notice [const childSource = parentSinkSlot.getPulseSource()]
              // can be omitted too, because otherwise [childSource === parentSinkSlot].
              // TODO test the performance of including this branch.
              const childSink = parentSinkSlot.setParent(parentSink); // Side effect
              visit(parentSinkSlot, childSink);
              continue;
            }
            const childSource = parentSinkSlot.getPulseSource();
            // Tightly coupled algorithmic magic:
            //   [childSource.isBuilt()]
            //   iff [parentSinkSlot.setParent] has been called
            //   iff [childSource] has been visited or is being visited.
            if (!childSource.isBuilt()) {
              const childSink = parentSinkSlot.setParent(parentSink); // Side effect
              visit(childSource, childSink);
              visitedChildren.add(childSource);
              continue;
            }
            if (!visitedChildren.has(childSource)) {
              throw new Error("Illegal pulse recursion!");
            }
            parentSinkSlot.setParent(parentSink); // Side effect
          }
          sortedSinks.push(parentSink); // Main effect
        };
        // Similar to the for loop in [visit], but we don't check for illegal loops,
        // because the child isn't in in the middle of being visited.
        for (const [parentSink, parentSinkSlot] of this._pulseGraphRootEdges) {
          if (parentSinkSlot.hasSingleParent()) {
            const childSink = parentSinkSlot.setParent(parentSink);
            visit(parentSinkSlot, childSink);
            continue;
          }
          const childSource = parentSinkSlot.getPulseSource();
          if (!childSource.isBuilt()) {
            const childSink = parentSinkSlot.setParent(parentSink);
            visit(childSource, childSink);
            visitedChildren.add(childSource);
            continue;
          }
          parentSinkSlot.setParent(parentSink);
        }
      }
    }

    class PushContext {
      constructor() {
        // We're able to use a weakMap without fear of losing access to the values
        // because the keys will be strongly referenced by a chain of parent pulsePushes.
        this._values = new WeakMap();
        this._actions = [];
      }

      read(pulsePush) {
        return this._values.get(pulsePush);
      }

      write(pulsePush, value) {
        this._values.set(pulsePush, value);
      }

      queueAction(action) {
        this._actions.push(action);
      }
    }

    // We separate this from pulsePull to allow for garbage collection.
    // All the strong references to this are from:
    // - Parent pulsePushes
    // - External event listeners (via inputPulse)
    // - Children pulsePushes that only have one parent
    // This is dead when:
    //   ((its parents are dead) and (its external event listeners are dead))
    //   or ((it has no children) and (its pulsePull is dead))
    class PulsePush {
      // The constructor is only used in newPubSub.
      // Poll and unsubscribe holds weak references to parent pulsePushes,
      // or a strong reference if there's only one parent.
      constructor(poll, unsubscribe) {
        // A monadic publish function that returns the current value of the pulsePush.
        // Returns undefined to represent non-occurrence of an event, such as in a filter.
        this._poll = poll;
        // Strong references. Children will only written to if one of their parents is.
        this._children = [];
        // Impure
        // Called when there are no more children and the pulsePull is dead.
        // Called at most once, either called from this.removeChild or this.onPulsePullDeath.
        // this.poll must never be called again after this._unsubscribe is called.
        this._unsubscribe = unsubscribe;
        // A condition to call this._unsubscribe in this.removeChild.
        this._isPulsePullDead = false;
        this.isHot = false;
        this.priority = 0;
      }

      // Push monad
      // Returns the children to be written to after this is written to.
      *poll() {
        const value = yield* this._poll();
        if (value === undefined) return [];
        yield this.write(value);
        // TODO do we really need to check priority?
        return this._children.filter(
          child => child.isHot && this.priority < child.priority
        );
      }

      // Push monad
      // Instead of storing the current value as a variable,
      // we store it in the monadic Push context,
      // so we can easily delete every pulsePush's value once the changes get flushed.
      read() {
        return context => context.read(this);
      }

      // Push monad
      // Mutable: context
      write(value) {
        return context => context.write(this, value);
      }

      // Pull monad
      // Mutable: context
      queueAddChild(child) {
        return context => context.queueAddChild(this, child);
      }

      // Impure: this._unsubscribe
      // Mutable: this._children
      // Will be called at most once per child.
      removeChild(child) {
        // TODO update numHotChildren
        const index = this._children.findIndex(child);
        that._children.splice(index, 1);
        if (this._children.length === 0 && this.isPulsePullDead) {
          this._unsubscribe();
        }
      }

      // Impure: this._unsubscribe
      onPulsePullDeath() {
        if (this._children.length === 0) {
          this._unsubscribe();
        } else {
          // You only have to set this true if there are children,
          // because this variable is only read in removeChild.
          this._isPulsePullDead = true;
        }
      }
    }

    // Push monad
    function* readWeakPulsePush(weak) {
      pulsePush = weak.deref();
      if (pulsePush === undefined) {
        return undefined;
      } else {
        return yield pulsePush.read();
      }
    }

    // We separate this from pulsePush to allow for garbage collection.
    // When this dies, it means no more children can be added to its pulsePush instance.
    class PulsePull {
      // Mutable: pulsePush
      // TODO confirm that this callback gets called.
      static _finalizers = new FinalizationRegistry(weakpulsePush =>
        weakpulsePush.deref()?.onPulsePullDeath()
      );

      // The constructor is only used in newPubSub.
      constructor(pulsePush) {
        this._pulsePush = new WeakRef(pulsePush);
        _finalizers.register(this, this._pulsePush);
      }

      // Pull monad
      // Mutable: pulsePush
      *subscribe(makeAction) {
        const parent = this._pulsePush.deref();
        if (parent === undefined) return () => {};

        const output = new Output(parent, makeAction);

        yield parent.queueAddChild(output);
        const unsubscribe = parent.removeChild(output);
        return unsubscribe;
      }

      // Pull monad
      *map(f) {
        const parent = this._pulsePush.deref();
        if (parent === undefined) return never;

        // TODO test what "this" is
        const [pulsePush, pulsePull] = newPubSub(
          function*() {
            // yield parent.read() !== undefined;
            return f(yield parent.read());
          },
          () => parent.removeChild(pulsePush)
        );

        yield parent.queueAddChild(pulsePush);
        return pulsePull;
      }

      // Pull monad
      *filter(predicate) {
        const parent = this._pulsePush.deref();
        if (parent === undefined) return never;

        const [pulsePush, pulsePull] = newPubSub(
          function*() {
            // value !== undefined
            const value = yield parent.read();
            return predicate(value) ? value : undefined;
          },
          () => parent.removeChild(pulsePush)
        );

        yield parent.queueAddChild(pulsePush);
        return pulsePull;
      }

      // Pull monad
      *merge(other, simultaneous = (a, b) => a) {
        // Don't hold references to this or other inside any closures
        const weakA = this._pulsePush;
        const weakB = other._pulsePush;

        const [pulsePush, pulsePull] = newPubSub(
          function*() {
            const a = yield* readWeakPulsePush(weakA);
            const b = yield* readWeakPulsePush(weakB);
            if (a === undefined) return b;
            if (b === undefined) return a;
            return simultaneous(a, b);
          },
          () => {
            weakA.deref()?.removeChild(pulsePush);
            weakB.deref()?.removeChild(pulsePush);
          }
        );

        yield* this.queueAddChild(pulsePush);
        yield* other.queueAddChild(pulsePush);
        return pulsePull;
      }

      // TODO for the sake of recursion, don't access _pulsePush
      // Pull monad
      *queueAddChild(child) {
        const pulsePush = this._pulsePush.deref();
        if (pulsePush !== undefined) {
          yield pulsePush.queueAddChild(child);
        }
      }
    }

    // Mutable: generator, context
    const runPull = generator => {
      let step = generator.next();
      const context = new PullContext();
      while (!step.done) {
        step = generator.next(step.value(context));
      }
      context._flushChanges();
    };

    // TODO rename
    // Mutable: generator, context
    const runPushMonad = generator => {
      let step = generator.next();
      const context = new PushContext();
      while (!step.done) {
        step = generator.next(step.value(context));
      }
      // TODO
    };

    // Push monad
    // Mutable: queue
    function* publish(pulsePush, value) {
      yield pulsePush.write(value);
      const queue = new PriorityQueue();
      queue.push(pulsePush);
      for (const pollable of queue) {
        const childrenToPoll = yield* pollable.poll();
        for (const child of childrenToPoll) {
          // Yes, I'm mutating the queue while iterating over it.
          queue.push(child);
        }
      }
    }

    class InputSink {
      // Impure: subscribe, runPushMonad
      // Subscribe takes a push function, attaches it as an event listener,
      // and returns an unsubscribe function.
      // We assume that this won't be pushed until the surrounding
      // pull monad finishes. If this assumption turns out false,
      // we can just defer subscriptions until the end of the monad.
      constructor(subscribe) {
        // TODO check if it captures the right "this"
        this._unsubscribe = subscribe(x => runPushMonad(publish(this, x)));
      }
    }

    class InputSource {
      // Impure: subscribe
      constructor(subscribe) {
        // TODO check if sink gets GC'd
        this._sink = new WeakRef(new InputSink(subscribe));
      }

      getPulseSource() {
        return this;
      }
      
      isBuilt() {
        return true;
      }

      isPushable() {
        return this._sink.deref() !== undefined;
      }
    }

    class SingleParentSource extends PulseSource {
      constructor() {
        this._sink = null;
      }
      
      hasSingleParent() {
        return true;
      }

      getPulseSource() {
        return this;
      }
      
      isBuilt() {
        return this._sink !== null;
      }
      
      // No methods beyond this point should be called if !this.isBuilt()

      isPushable() {
        return this._sink.deref() !== undefined;
      }
    }

    class DoubleParentSource extends PulseSource {
      constructor() {
        this._sink = null;
      }

      getPulseSource() {
        return this;
      }
      
      isBuilt() {
        this._sink !== null;
      }
      
      // No methods beyond this point should be called if !this.isBuilt()

      isPushable() {
        return this._sink.deref() !== undefined;
      }
    }

    class ParentSlotA {
      constructor(doubleParentSource) {
        this._source = doubleParentSource;
      }
      
      hasSingleParent() {
        return false;
      }

      getPulseSource() {
        return this._source;
      }
    }

    class ParentSlotB {
      constructor(doubleParentSource) {
        this._source = doubleParentSource;
      }
      
      hasSingleParent() {
        return false;
      }

      getPulseSource() {
        return this._source;
      }
    }

    class OutputSource {
      static isHot = true;

      constructor(pulseSource, makeAction) {
        this._pulseSource = pulseSource;
        this._makeAction = makeAction;
        this.priority = 0;
      }
      
      hasSingleParent() {
        return true;
      }

      getPulseSource() {
        return this;
      }

      // Push monad
      *poll() {
        // value !== undefined because there's only one parent pulseSource
        const value = yield this._pulseSource.read();
        // Mutable: context
        yield context => context.queueAction(this._makeAction(value));
        return [];
      }
    }

    class LoopPulseSource {
      constructor() {
        this._pulse = null;
      }

      getPulseSource() {
        if (this._pulse === null) {
          throw new Error("Must call [loop] for each [LoopPulseSource]!");
        }
        return this._pulse;
      }

      // Relies on the unpushable check in this.loop.
      // Otherwise, we'd have to return true until this.loop was called.
      isPushable() {
        return false;
      }
      
      isBuilt() {
        return false;
      }

      loop(pulse) {
        if (this._pulse !== null) {
          throw new Error("Can't call [LoopPulseSource.loop] more than once!");
        }
        if (pulse.isBuilt()) {
          throw new Error("Can't use a pulse that's already been built!");
        }
        this._pulse = pulse;
      }
    }

    const never = { isPushable: () => false };

    // Pull monad
    function* tag(pulse, latchGet) {
      const result = new SingleParentSource();
      yield addPulseGraphEdge(pulse, result);
      return result;
    }

    // Pull monad
    function* mapTag(pulse, latchGet, combine) {
      const result = new SingleParentSource();
      yield addPulseGraphEdge(pulse, result);
      return result;
    }

    // Pull monad
    function* map(pulse, f) {
      const result = new SingleParentSource();
      yield addPulseGraphEdge(pulse, result);
      return result;
    }

    // Pull monad
    function* filter(pulse, predicate) {
      const result = new SingleParentSource();
      yield addPulseGraphEdge(pulse, result);
      return result;
    }

    // Pull monad
    function* merge(pulseA, pulseB) {
      const result = new DoubleParentSource();
      yield addPulseGraphEdge(pulseA, new ParentSlotA(result));
      yield addPulseGraphEdge(pulseB, new ParentSlotB(result));
      return result;
    }

    // Pull monad
    function* switchE(pulseOfPulse) {
      // TODO
      return never;
    }

    const addPulseGraphEdge = (parent, child) => context =>
      context.addPulseGraphEdge(parent, child);

    const getClicks = domNode =>
      new InputSource(push => domNode.addEventListener("click", push));

    // TODO replace with behavior
    const getInputValues = domNode => () => domNode.value;

    // TODO optimize with binary tree
    // TODO use cached moments
    function* mergeBind(pulse, f) {
      const result = new LoopPulseSource();
      result.loop(
        yield* switchE(yield* map(result, mergeMe => merge(f(mergeMe), result)))
      );
      return result;
    }

    function* userDatabase({
      insertions,
      usernamesToRemove,
      clears,
      signupAttempts
    }) {
      let internalTable = [];

      const protoFindUsername = (start, end, username) => {
        if (start === end) {
          return start;
        }
        const middle = Math.floor((start + end) / 2);
        if (internalTable[middle].username < username) {
          return protoFindUsername(middle + 1, end, username);
        } else {
          return protoFindUsername(start, middle, username);
        }
      };
      const findUsername = username =>
        protoFindUsername(0, internalTable.length, username);

      let signups = yield* filter(
        yield* map(signupAttempts, user => {
          const index = findUsername(user.username);
          const foundUser = internalTable[index];
          if (foundUser === undefined || foundUser.username !== user.username) {
            return [index, user];
          }
          return null;
        }),
        x => x !== null
      );
      new OutputSource(signups, ([index, user]) =>
        internalTable.splice(index, 0, user)
      );

      insertions = yield* map(insertions, ({ username, password }) => {
        const index = findUsername(username);
        const foundUser = internalTable[index];
        if (foundUser === undefined || foundUser.username !== username) {
          return ["createUser", index, { username, password }];
        }
        if (foundUser.password !== password) {
          return ["changePassword", index, password];
        }
        return [];
      });
      const createUserInsertions = yield* map(
        yield* filter(insertions, x => x[0] === "createUser"),
        ([, index, user]) => [index, user]
      );
      new OutputSource(createUserInsertions, ([index, user]) => {
        internalTable.splice(index, 0, user);
      });
      const createdUsers = yield* merge(createUserInsertions, signups);
      const changePasswordInsertions = yield* filter(
        insertions,
        x => x[0] === "changePassword"
      );
      const passwordChanges = yield* map(
        changePasswordInsertions,
        ([, index, password]) => ({
          index,
          username: internalTable[index].username,
          password
        })
      );
      new OutputSource(
        passwordChanges,
        ({ index, password }) => (internalTable[index].password = password)
      );
      const removedUsers = yield* map(usernamesToRemove, username => ({
        index: findUsername(username),
        username
      }));
      new OutputSource(removedUsers, ({ index }) =>
        internalTable.splice(index, 1)
      );
      clears = yield* filter(clears, _ => internalTable.length !== 0);
      new OutputSource(clears, _ => (internalTable = []));

      const tryLogins = stream =>
        stream.map(({ username, password }) => {
          const foundUser = internalTable[findUsername(username)];
          return (
            foundUser !== undefined &&
            foundUser.username === username &&
            foundUser.password === password
          );
        });
      return {
        createdUsers,
        passwordChanges,
        removedUsers,
        clears,
        tryLogins,
        signups
      };
    }

    const nodeBuilder = (constructor, modifiers) => {
      const fromImpureBuilder = impureBuild => {
        const builder = (...children) =>
          fromImpureBuilder(varsOut => {
            const node = impureBuild(varsOut);
            // Use append instead of appendChild because we need to handle text nodes
            node.append(...children.map(child => child._impureBuild(varsOut)));
            return node;
          });
        for (const [key, modifier] of Object.entries(modifiers)) {
          builder[key] = (...args) =>
            fromImpureBuilder(varsOut => {
              const node = impureBuild(varsOut);
              modifier(...args)(node);
              return node;
            });
        }
        builder._impureBuild = impureBuild;
        builder.build = _ => {
          const varsOut = {};
          varsOut.root = impureBuild(varsOut);
          return varsOut;
        };
        builder.var = name =>
          fromImpureBuilder(varsOut => {
            const node = impureBuild(varsOut);
            varsOut[name] = node;
            return node;
          });
        return builder;
      };
      return fromImpureBuilder(constructor);
    };
    const div = nodeBuilder(_ => document.createElement("div"), {});
    const button = nodeBuilder(_ => document.createElement("button"), {
      textContent: textContent => node => (node.textContent = textContent)
    });
    const textInput = nodeBuilder(_ => {
      const node = document.createElement("input");
      node.type = "text";
      return node;
    }, {});
    const p = nodeBuilder(_ => document.createElement("p"), {});
    const table = nodeBuilder(_ => document.createElement("table"), {});
    const thead = nodeBuilder(_ => document.createElement("thead"), {});
    const tbody = nodeBuilder(_ => document.createElement("tbody"), {});
    const tr = nodeBuilder(_ => document.createElement("tr"), {});
    const th = nodeBuilder(_ => document.createElement("th"), {
      textContent: textContent => node => (node.textContent = textContent)
    });
    const td = nodeBuilder(_ => document.createElement("td"), {
      textContent: textContent => node => (node.textContent = textContent)
    });
    const text = string => ({
      _impureBuild: _ => string
    });

    function* userTable(signupAttempts) {
      const {
        root: userTableDiv,
        clearButton,
        userTable,
        usernameInsertInput,
        passwordInsertInput,
        insertButton,
        userTableBody
      } = div(
        button.var("clearButton").textContent("Clear"),
        table.var("userTable")(
          thead(
            tr(th.textContent("Username"), th.textContent("Password")),
            tr(
              td(textInput.var("usernameInsertInput")),
              td(textInput.var("passwordInsertInput")),
              td(button.var("insertButton").textContent("Insert"))
            )
          ),
          tbody.var("userTableBody")
        )
      ).build();

      const insertions = yield* filter(
        yield* mapTag(
          yield* tag(
            getClicks(insertButton),
            getInputValues(usernameInsertInput)
          ),
          getInputValues(passwordInsertInput),
          (username, password) => ({
            username,
            password
          })
        ),
        ({ username, password }) => username !== "" && password !== ""
      );

      const usernamesToRemove = new LoopPulseSource();

      const {
        createdUsers,
        passwordChanges,
        removedUsers,
        clears,
        tryLogins
      } = yield* userDatabase({
        insertions,
        usernamesToRemove,
        clears: getClicks(clearButton),
        signupAttempts
      });

      new OutputSource(insertions, () => {
        usernameInsertInput.value = "";
        passwordInsertInput.value = "";
      });

      // TODO make pure
      usernamesToRemove.loop(
        yield* mergeBind(createdUsers, ([index, user]) => {
          const { root: rowElement, xButton } = tr(
            td.textContent(user.username),
            td.textContent(user.password),
            td(button.var("xButton").textContent("X"))
          ).build();
          if (index === userTableBody.children.length) {
            userTableBody.appendChild(rowElement);
          } else {
            userTableBody.insertBefore(
              rowElement,
              userTableBody.children[index]
            );
          }
          return getClicks(xButton).map(_ => user.username);
        })
      );

      new OutputSource(passwordChanges, ({ index, password }) => {
        const rowElement = userTableBody.children[index];
        rowElement.children[1].textContent = password;
      });

      new OutputSource(removedUsers, ({ index }) =>
        userTableBody.children[index].remove()
      );

      new OutputSource(clears, _ => (userTableBody.innerHTML = ""));

      return { userTableDiv, passwordChanges, removedUsers, clears, tryLogins };
    }

    // Moment monad
    function* main() {
      const signupAttempts = new LoopPulseSource();

      //div(yield* userTable(signupAttempts).var("userTable"), slot(loginDiv))
      const {
        userTableDiv,
        passwordChanges,
        removedUsers,
        clears,
        tryLogins
      } = yield* userTable(signupAttempts);
      document.body.appendChild(userTableDiv);
      document.body.appendChild(document.createElement("p"));

      const createLoginDiv = _ => {
        const {
          root,
          usernameInput,
          passwordInput,
          loginButton,
          statusText,
          signupButton
        } = div(
          text("Username:"),
          textInput.var("usernameInput"),
          text("Password:"),
          textInput.var("passwordInput"),
          button.var("loginButton").textContent("Login"),
          p.var("statusText"),
          text("Don't have an account yet?"),
          button.var("signupButton").textContent("Signup")
        ).build();

        let loginAttempts = getClicks(loginButton)
          .tag(getInputValues(usernameInput))
          .mapTag(getInputValues(passwordInput), (username, password) => ({
            username,
            password
          }));
        loginAttempts
          .filter(({ username }) => username === "")
          .map(_ => (statusText.textContent = "Username required!"));
        loginAttempts
          .filter(
            ({ username, password }) => username !== "" && password === ""
          )
          .map(_ => (statusText.textContent = "Password required!"));
        loginAttempts = tryLogins(
          loginAttempts.filter(
            ({ username, password }) => username !== "" && password !== ""
          )
        );
        loginAttempts
          .filter(success => !success)
          .map(_ => (statusText.textContent = `Invalid login!`));

        return [
          root,
          loginAttempts
            .filter(success => success)
            .tag(getInputValues(usernameInput))
            .map(createLoggedInDiv)
            .merge(getClicks(signupButton).map(createSignupDiv)),
          never
        ];
      };

      const createSignupDiv = _ => {
        const {
          root,
          usernameInput,
          passwordInput,
          signupButton,
          statusText,
          loginButton
        } = div(
          text("Username:"),
          textInput.var("usernameInput"),
          text("Password:"),
          textInput.var("passwordInput"),
          button.var("signupButton").textContent("Signup"),
          p.var("statusText"),
          text("Already have an account?"),
          button.var("loginButton").textContent("Login")
        ).build();

        const signupAttempts = getClicks(signupButton)
          .tag(getInputValues(usernameInput))
          .mapTag(getInputValues(passwordInput), (username, password) => ({
            username,
            password
          }));
        signupAttempts
          .filter(({ username }) => username === "")
          .map(_ => (statusText.textContent = "Username required!"));
        signupAttempts
          .filter(
            ({ username, password }) => username !== "" && password === ""
          )
          .map(_ => (statusText.textContent = "Password required!"));

        return [
          root,
          getClicks(loginButton).map(createLoginDiv),
          signupAttempts.filter(
            ({ username, password }) => username !== "" && password !== ""
          )
        ];
      };

      const createLoggedInDiv = username => {
        const { root: loggedInDiv, logoutButton } = div(
          text(`Hello ${username}`),
          button.var("logoutButton").textContent("Logout")
        ).build();

        return [
          loggedInDiv,
          getClicks(logoutButton)
            .merge(
              passwordChanges
                .merge(removedUsers)
                .filter(x => x.username === username)
            )
            .merge(clears)
            .map(createLoginDiv),
          never
        ];
      };

      let publishStartPage;
      const startPage = new InputSource(p => (publishStartPage = p));
      const start = _ => publishStartPage(createLoginDiv());

      const authPages = new LoopPulseSource();
      const appPages = yield* merge(authPages, startPage);

      new OutputSource(appPages, ([appDiv, ,]) => {
        document.body.lastElementChild.remove();
        document.body.appendChild(appDiv);
      });

      signupAttempts.loop(
        yield* switchE(
          yield* map(appPages, ([, , signupAttempts]) => signupAttempts)
        )
      );
      authPages.loop(
        yield* switchE(yield* map(appPages, ([, nextAuthPage]) => nextAuthPage))
      );

      return start;
    }

    runPull(main())();
  </script>
</html>
