<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Login v4</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#164113" />
    <meta name="msapplication-TileColor" content="#006600" />
    <meta name="theme-color" content="#006600" />
  </head>
  <body></body>
  <script>
    const Util = (() => {
      // TODO learn how imports work so I can use a library instead of this custom implementation.
      class PriorityQueue {
        constructor() {
          this._array = [];
        }

        push(value) {
          let index = this._array.length;
          // Special cases of the loop below, so we can avoid writing this._array.push(null)
          if (index === 0) {
            this._array.push(value);
            return;
          }
          const parentIndex = Math.floor((index - 1) / 2);
          const parent = this._array[parentIndex];
          if (parent.getPriority() <= value.getPriority()) {
            this._array.push(value);
            return;
          }
          this._array.push(parent);
          index = parentIndex;

          // This is where the real logic is
          while (0 < index) {
            const parentIndex = Math.floor((index - 1) / 2);
            const parent = this._array[parentIndex];

            if (parent.getPriority() <= value.getPriority()) break;

            this._array[index] = parent;
            index = parentIndex;
          }

          this._array[index] = value;
        }

        next() {
          switch (this._array.length) {
            case 0:
              return { done: true };
            case 1:
              return {
                value: this._array.pop(),
                done: false
              };
          }
          const value = this._array[0];

          const index = 0;
          const end = this._array.pop();

          while (true) {
            const swapIndex = index;
            const swap = end;

            // swap = min(swap, leftChild)
            const leftIndex = 2 * index + 1;
            const leftChild = this._array[leftIndex];
            if (leftChild && leftChild.priority < swap.priority) {
              swapIndex = leftIndex;
              swap = leftChild;
            }

            // swap = min(swap, rightChild)
            const rightIndex = leftIndex + 1;
            const rightChild = this._array[rightIndex];
            if (rightChild && rightChild.priority < swap.priority) {
              swapIndex = rightIndex;
              swap = rightChild;
            }

            if (swapIndex === index) break;
            this._array[index] = swap;
            index = swapIndex;
          }

          this._array[index] = end;
          return { value, done: false };
        }

        [Symbol.iterator]() {
          return this;
        }
      }

      class ChildList {
        constructor() {
          this._prev = this;
          this._next = this;
        }

        add(value) {
          const result = new ChildListNode(this, value, this._next);
          this._next._prev = result;
          this._next = result;
          return result;
        }

        [Symbol.iterator]() {
          let current = this._next;
          return {
            next: () => {
              if (current === this) {
                return { done: true };
              }
              const value = current._value;
              current = current._next;
              return { done: false, value };
            }
          };
        }
      }

      class ChildListNode {
        constructor(prev, value, next) {
          this._prev = prev;
          this._value = value;
          this._next = next;
        }

        remove() {
          this._prev._next = this._next;
          this._next._prev = this._prev;
        }
      }

      const weakRefUndefined = { deref: () => undefined };

      // We use this so that type errors like [null + 1] don't pass silently.
      const nullNumber = Symbol();

      const weakMapFromEdges = edges => {
        const graph = new WeakMap();
        for (const [parent, child] of edges) {
          const children = graph.get(parent);
          if (children === undefined) {
            graph.set(parent, [child]);
          } else {
            children.push(child);
          }
        }
        return graph;
      };

      return {
        PriorityQueue,
        ChildList,
        weakRefUndefined,
        nullNumber,
        weakMapFromEdges
      };
    })();
    const Build = (() => {
      // It's not obvious because the logic is distributed so widely,
      // but this is a topological sort of sources.
      // [source.isBuilt() && !(yield isVisited(source))] means a source is being visited.
      // [yield isVisited(source)] means a source has been visited in the past.
      // The results of the sort go in Context._sortedSinks.
      // As a side effect, the visited sources have their sinks built.

      class Context {
        constructor(graph) {
          this._graph = graph;
          this._sortedSinks = [];
          this._visited = new WeakSet();
        }

        getSourceChildren(source) {
          return this._graph.get(source) ?? [];
        }

        pushSortedSink(sink) {
          this._sortedSinks.push(sink);
        }

        markVisited(source) {
          this._visited.add(source);
        }

        isVisited(source) {
          return this._visited.has(source);
        }

        _endMonad() {
          this._sortedSinks.reverse().map(sink => sink.initPriority());
        }
      }

      const getSourceChildren = source => context =>
        context.getSourceChildren(source);
      const pushSortedSink = sink => context => context.pushSortedSink(sink);
      const markVisited = source => context => context.markVisited(source);
      const isVisited = source => context => context.isVisited(source);

      // TODO rename
      function* buildRoots(roots) {
        for (const [parentSink, parentSinkSlot] of roots) {
          yield* parentSinkSlot.buildRoot(parentSink);
        }
      }
      // TODO profile to see if [parentSink] should be made into a function argument
      function* buildVertex(parentSource) {
        const parentSink = parentSource.getSink();
        const parentSlots = yield getSourceChildren(parentSource);
        for (const parentSlot of parentSlots) {
          yield* parentSlot.buildEdge(parentSink);
        }
        yield pushSortedSink(parentSink);
      }

      return {
        Context,
        getSourceChildren,
        pushSortedSink,
        markVisited,
        isVisited,
        buildRoots,
        buildVertex
      };
    })();
    const Pull = (() => {
      class Context {
        constructor() {
          this._graphEdges = [];
          this._graphRoots = [];
        }

        // The [parentSinkSlot] is a wrapper around the child.
        addGraphEdge(parentSource, parentSinkSlot) {
          if (!parentSource.isBuilt()) {
            this._graphEdges.push([parentSource, parentSinkSlot]);
            return;
          }
          const parentSink = parentSource.getSink();
          if (parentSink !== undefined) {
            this._graphRoots.push([parentSink, parentSinkSlot]);
          }
          // TODO use profiler to tell which implementation to use.
          // Alternate implementation:
          //   const parentSink = parentSource.getSink();
          //   if (parentSink !== undefined) {
          //     this._graphRoots.push([parentSink, parentSinkSlot]);
          //   } else {
          //     this._graphEdges.push([parentSource, parentSinkSlot]);
          //   }
        }

        _endMonad() {
          runMonad(
            new Build.Context(Util.weakMapFromEdges(this._graphEdges)),
            Build.buildRoots(this._graphRoots)
          );
        }
      }

      const addGraphEdge = (parent, child) => context =>
        context.addGraphEdge(parent, child);

      return { Context, addGraphEdge };
    })();
    const Push = (() => {
      class Context {
        constructor() {
          // We're able to use a weakMap without fear of losing access to the values
          // because the keys will be strongly referenced by a chain of parent pulsePushes.
          this._values = new WeakMap();
          this._actions = [];
          this._momentContext = new Moment.Context();
        }

        writeSink(sink, value) {
          // Store an object so that we can differentiate between
          // an unwritten sink and a sink that had [undefined] written to it.
          // Essentially, it's an ad-hoc maybe monad.
          this._values.set(sink, { value });
        }

        readSink(sink) {
          return this._values.get(sink);
        }

        enqueueAction(handle, value) {
          this._actions.push([handle, value]);
        }
        
        pull(monadicMomentValue) {
          const generator = monadicMomentValue();
          let step = generator.next();
          while (!step.done) {
            step = generator.next(step.value(this._momentContext));
          }
          return step.value;
        }

        _endMonad() {
          this._momentContext._endMonad();
          for (const [handle, value] of this._actions) {
            handle(value);
          }
        }
      }

      const writeSink = (sink, value) => context =>
        context.writeSink(sink, value);
      const readSink = sink => context => context.readSink(sink);
      const enqueueAction = (handle, value) => context => context.enqueueAction(handle, value);
      const pull = monadicMomentValue => context => context.pull(monadicMomentValue);

      // Mutable: queue
      function* push(sink, value) {
        yield writeSink(sink, value);
        const queue = new Util.PriorityQueue();
        queue.push(sink);
        for (const sink of queue) {
          const childrenToPoll = yield* sink.poll();
          for (const child of childrenToPoll) {
            // Yes, I'm mutating the queue while iterating over it.
            queue.push(child);
          }
        }
      }

      return { Context, writeSink, readSink, enqueueAction, pull, push };
    })();
    const Moment = (() => {
      class Context {
        constructor() {
          this._monadicPullValues = [];
        }

        pull(monadicPullValue) {
          this._monadicPullValues.push(monadicPullValue);
        }

        _endMonad() {
          const monadicPullValues = this._monadicPullValues;
          runMonad(
            new Pull.Context(),
            (function*() {
              for (const monadicPullValue of monadicPullValues) {
                yield* monadicPullValue();
              }
            })()
          );
        }
      }

      const pull = monadicPullValue => context =>
        context.pull(monadicPullValue);

      return { Context, pull };
    })();

    // Mutable: context, generator
    const runMonad = (context, generator) => {
      let step = generator.next();
      while (!step.done) {
        step = generator.next(step.value(context));
      }
      context._endMonad();
      // TODO do we really need to return?
      return step.value;
    };

    class InputSink {
      // Impure: subscribe, runMonad
      // Subscribe takes a push function, attaches it as an event listener,
      // and returns an unsubscribe function.
      // We assume that this won't be pushed until the surrounding
      // pull monad finishes. If this assumption turns out false,
      // we can just defer subscriptions until the end of the monad.
      constructor(subscribe) {
        // TODO check if it captures the right "this"
        this._unsubscribe = subscribe(x =>
          runMonad(new Push.Context(), Push.push(this, x))
        );
        this._children = new Util.ChildList();
      }

      linkChild(childSink) {
        return this._children.add(childSink);
      }

      getPriority() {
        return 0;
      }

      // Push monad
      // Don't write because it's assumed that was already done in [Push.push].
      *poll() {
        return this._children;
      }
    }

    class InputSource {
      // Impure: subscribe
      constructor(subscribe) {
        // TODO check if sink gets GC'd
        this._sink = new WeakRef(new InputSink(subscribe));
      }

      isBuilt() {
        return true;
      }

      getSink() {
        return this._sink.deref();
      }
    }

    // Both a source and a sink
    class OutputPulse {
      constructor(handle) {
        this._handle = handle;
        this._parentSink = null;
        this._childListNode = null;
        this._priority = Util.nullNumber;
      }

      // Build monad
      *buildEdge(parentSink) {
        this._parentSink = parentSink;
        this._childListNode = parentSink.linkChild(this);
        yield Build.pushSortedSink(this); // Equivalent to [yield* buildVertex(this)]
      }

      // Build monad
      *buildRoot(parentSink) {
        yield* this.buildEdge(parentSink);
      }

      // [this._parentSink !== null]
      initPriority() {
        this._priority = this._parentSink.getPriority() + 1;
      }

      getPriority() {
        return this._priority;
      }

      // Push monad
      *poll() {
        const parentValue = yield Push.readSink(this._parentSink);
        if (parentValue !== undefined) {
          yield Push.enqueueAction(this._handle, parentValue.value);
        }
        return [];
      }
    }

    const neverSource = {
      isBuilt: () => false
    };

    class MergeSink {
      constructor(combine) {
        this._combine = combine;
        this._children = new Util.ChildList();
        this._parentSinkA = Util.weakRefUndefined;
        this._parentSinkB = Util.weakRefUndefined;
        this._childListNodeA = Util.weakRefUndefined;
        this._childListNodeB = Util.weakRefUndefined;
        this._priority = Util.nullNumber;
      }

      linkChild(childSink) {
        return this._children.add(childSink);
      }

      linkParentA(parentSink) {
        this._parentSinkA = new WeakRef(parentSink);
        this._childListNodeA = new WeakRef(parentSink.linkChild(this));
      }

      linkParentB(parentSink) {
        this._parentSinkB = new WeakRef(parentSink);
        this._childListNodeB = new WeakRef(parentSink.linkChild(this));
      }

      // [parentA !== undefined || parentB !== undefined]
      initPriority() {
        const parentA = this._parentSinkA.deref();
        const parentB = this._parentSinkB.deref();
        if (parentA === undefined) {
          this._priority = parentB.getPriority() + 1;
        } else if (parentB === undefined) {
          this._priority = parentA.getPriority() + 1;
        } else {
          this._priority =
            Math.max(parentA.getPriority() + parentB.getPriority()) + 1;
        }
      }

      // [this._priority !== null]
      getPriority() {
        return this._priority;
      }

      // Push monad
      // [parentAValue !== undefined || parentBValue !== undefined]
      *poll() {
        const parentAValue = yield Push.readSink(this._parentSinkA.deref());
        const parentBValue = yield Push.readSink(this._parentSinkB.deref());
        if (parentAValue === undefined) {
          yield Push.writeSink(this, parentBValue.value);
        } else if (parentBValue === undefined) {
          yield Push.writeSink(this, parentAValue.value);
        } else {
          yield Push.writeSink(
            this,
            this._combine(parentAValue.value, parentBValue.value)
          );
        }
        return this._children;
      }
    }

    // Promiscuous state sharing with [MergeParentSlot]
    class MergeSource {
      // [sinkBuilder] is a function that makes this source's sink.
      // [this._sink] has a different interface depending on [this.isBuilt()]
      constructor(sinkBuilder) {
        this._sink = sinkBuilder;
      }

      // Easier than polymorphism
      isBuilt() {
        return this._sink.constructor === WeakRef;
      }

      // [this.isBuilt()]
      getSink() {
        return this._sink.deref();
      }
    }

    // Promiscious state sharing with [MergeSource]
    class MergeParentSlot {
      constructor(childSource, linkParent) {
        this._childSource = childSource;
        this._linkParent = linkParent;
      }

      // Build monad
      // Mutable: parentSink, this._childSource._sink
      *buildEdge(parentSink) {
        if (!this._childSource.isBuilt()) {
          // Child not visited
          const childSink = this._childSource._sink();
          this._linkParent(parentSink, childSink);
          this._childSource._sink = new WeakRef(childSink);
          yield* Build.buildVertex(this._childSource);
          yield Build.markVisited(this._childSource);
        } else if (!(yield Build.isVisited(this._childSource))) {
          // Child being visited
          throw new Error("Illegal pulse recursion!");
        } else {
          // Child was visited
          this._linkParent(parentSink, this._childSource.getSink());
        }
      }

      // Build monad
      // Mutable: parentSink, this._childSource._sink
      // The same as [this.buildEdge] but without checking for illegal pulse recursion.
      *buildRoot(parentSink) {
        if (!this._childSource.isBuilt()) {
          // Child not visited
          const childSink = this._childSource._sink();
          this._linkParent(parentSink, childSink);
          this._childSource._sink = new WeakRef(childSink);
          yield* Build.buildVertex(this._childSource);
          yield Build.markVisited(this._childSource);
        } else {
          // Child was visited
          this._linkParent(parentSink, this._childSource.getSink());
        }
      }
    }

    class SingleParentSink {
      constructor(parentSink, mapParentValue) {
        this._children = new Util.ChildList();
        this._parentSink = parentSink;
        this._childListNode = parentSink.linkChild(this);
        this._priority = Util.nullNumber;
        this._mapParentValue = mapParentValue;
      }

      linkChild(childSink) {
        return this._children.add(childSink);
      }

      initPriority() {
        this._priority = this._parentSink.getPriority() + 1;
      }

      // [this._priority !== null]
      getPriority() {
        return this._priority;
      }

      // Push monad
      *poll() {
        const parentValue = yield Push.readSink(this._parentSink);
        if (parentValue === undefined) {
          // TODO is this check necessary?
          return [];
        }
        const value = this._mapParentValue(parentValue.value);
        if (value === undefined) {
          return [];
        }
        yield Push.writeSink(this, value.value);
        return this._children;
      }
    }

    class SingleParentSource {
      // [sinkBuilder] is a function that takes a parent sink to make this source's sink.
      // [this._sink] has a different interface depending on [this.isBuilt()]
      constructor(sinkBuilder) {
        this._sink = sinkBuilder;
      }

      // Easier than polymorphism
      isBuilt() {
        return this._sink.constructor === WeakRef;
      }

      // [this.isBuilt()]
      getSink() {
        return this._sink.deref();
      }

      // Build monad
      // [!this.isBuilt()]
      *buildEdge(parentSink) {
        this._sink = new WeakRef(this._sink(parentSink));
        yield* Build.buildVertex(this);
      }

      // Build monad
      // [!this.isBuilt()]
      *buildRoot(parentSink) {
        yield* this.buildEdge(parentSink);
      }
    }

    class SwitchESink {
      constructor() {
        this._children = new Util.ChildList();
        this._parentSink = Util.weakRefUndefined;
        this._childListNode = Util.weakRefUndefined;
        // Any number would work, but we choose a high one to reduce
        // the workload of [this.setParent].
        this._priority = 1000;
      }

      linkChild(childSink) {
        return this._children.add(childSink);
      }

      // [this._priority !== null]
      getPriority() {
        return this._priority;
      }

      // TODO use a surrounding monad.
      setParent(parentEvent) {
        // TODO unsubscribe from [this._parentSink];
        const parentSource = runMonad(new Pull.Context(), parentEvent());
        const parentSink = parentSource.getSink();
        if (parentSink === undefined) {
          this._parentSink = Util.weakRefUndefined;
          this._childListNode = Util.weakRefUndefined;
          return;
        }
        this._parentSink = new WeakRef(parentSink);
        this._childListNode = new WeakRef(parentSink.linkChild(this));
        // TODO decrement parent priority
      }

      // Push monad
      *poll() {
        // TODO
      }
    }

    class SwitchESource {
      constructor(sink) {
        this._sink = new WeakRef(sink);
      }

      isBuilt() {
        return true;
      }

      getSink() {
        return this._sink.deref();
      }
    }
    
    class ObserveESink {
      constructor(parentSink) {
        this._children = new Util.ChildList();
        this._parentSink = parentSink;
        this._childListNode = parentSink.linkChild(this);
        this._priority = Util.nullNumber;
      }

      linkChild(childSink) {
        return this._children.add(childSink);
      }

      initPriority() {
        this._priority = this._parentSink.getPriority() + 1;
      }

      // [this._priority !== null]
      getPriority() {
        return this._priority;
      }

      // Push monad
      *poll() {
        const parentValue = yield Push.readSink(this._parentSink);
        const value = yield Push.pull(parentValue.value);
        yield Push.writeSink(this, value);
        return this._children;
      }
    }

    const assertIsEvent = event => {
      if (event.constructor.name !== "GeneratorFunction") {
        throw new Error("event is not a generator function!");
      }
    };

    ////////////////
    // Pull monad //

    const eventLoop = () => {
      let event = null;
      const result = function*() {
        if (event === null) {
          throw new Error("Must call [loop] on every [eventLoop]!");
        }
        return yield* event();
      };
      result.loop = setTo => (event = setTo);
      return result;
    };

    const input = subscribe => {
      const source = new InputSource(subscribe);
      return function*() {
        return source;
      };
    };

    function* never() {
      return neverSource;
    }

    // TODO mergeWith
    const merge = (eventA, eventB, combine = (a, b) => a) => {
      assertIsEvent(eventA);
      assertIsEvent(eventB);
      let result = null;
      return function*() {
        if (result != null) {
          return result;
        }
        result = new MergeSource(() => new MergeSink(combine));
        yield Pull.addGraphEdge(
          yield* eventA(),
          new MergeParentSlot(result, (parentSink, childSink) =>
            childSink.linkParentA(parentSink)
          )
        );
        yield Pull.addGraphEdge(
          yield* eventB(),
          new MergeParentSlot(result, (parentSink, childSink) =>
            childSink.linkParentB(parentSink)
          )
        );
        return result;
      };
    };

    const singleParentEvent = (parentEvent, mapParentValue) => {
      assertIsEvent(parentEvent);
      if (!(mapParentValue instanceof Function)) {
        throw new TypeError("mapParentValue is not a function");
      }
      let result = null;
      return function*() {
        if (result != null) {
          return result;
        }
        result = new SingleParentSource(
          parentSink => new SingleParentSink(parentSink, mapParentValue)
        );
        yield Pull.addGraphEdge(yield* parentEvent(), result);
        return result;
      };
    };

    const filter = (event, predicate) => singleParentEvent(event, value => predicate(value) ? {value} : undefined);
    const map = (event, f) => singleParentEvent(event, x => ({value: f(x)}));
    const mapTag = (event, latchGet, combine) =>
      singleParentEvent(event, x => ({value: combine(x, latchGet())}));
    const tag = (event, latchGet) => singleParentEvent(event, () => ({value: latchGet()}));
    
    const observeE = event => {
      let result = null;
      return function*() {
        if (result !== null) {
          return result;
        }
        result = new SingleParentSource(
          parentSink => new ObserveESink(parentSink)
        );
        yield Pull.addGraphEdge(yield* event(), result);
        return result;
      }
    }

    const getClicks = domNode =>
      input(push => domNode.addEventListener("click", push));

    // Pull monad //
    ////////////////

    //////////////////
    // Moment monad //

    // TODO unsubscribe
    const output = (event, handle) =>
      Moment.pull(function*() {
        const result = new OutputPulse(handle);
        yield Pull.addGraphEdge(yield* event(), result);
        const unsubscribe = undefined;
        return unsubscribe;
      });

    function* switchE(eventOfEvent) {
      const sink = new SwitchESink();
      const source = new SwitchESource(sink);
      yield output(eventOfEvent, event => sink.setParent(event));
      // TODO fix memory leak
      return function*() {
        return source;
      };
    }

    // TODO optimize with binary tree
    function* mergeBind(eventOfEvent, f) {
      let current = never;
      const next = map(eventOfEvent, event => merge(f(event), current));
      yield output(next, event => (current = event));
      return yield* switchE(next);
    }

    // Moment monad //
    //////////////////

    // TODO replace with behavior
    const getInputValues = domNode => () => domNode.value;

    function* userDatabase({
      insertions,
      usernamesToRemove,
      clears,
      signupAttempts
    }) {
      let internalTable = [];

      const protoFindUsername = (start, end, username) => {
        if (start === end) {
          return start;
        }
        const middle = Math.floor((start + end) / 2);
        if (internalTable[middle].username < username) {
          return protoFindUsername(middle + 1, end, username);
        } else {
          return protoFindUsername(start, middle, username);
        }
      };
      const findUsername = username =>
        protoFindUsername(0, internalTable.length, username);

      let signups = filter(
        map(signupAttempts, user => {
          const index = findUsername(user.username);
          const foundUser = internalTable[index];
          if (foundUser === undefined || foundUser.username !== user.username) {
            return [index, user];
          }
          return null;
        }),
        x => x !== null
      );
      yield output(signups, ([index, user]) =>
        internalTable.splice(index, 0, user)
      );

      insertions = map(insertions, ({ username, password }) => {
        const index = findUsername(username);
        const foundUser = internalTable[index];
        if (foundUser === undefined || foundUser.username !== username) {
          return ["createUser", index, { username, password }];
        }
        if (foundUser.password !== password) {
          return ["changePassword", index, password];
        }
        return [];
      });
      const createUserInsertions = map(
        filter(insertions, x => x[0] === "createUser"),
        ([, index, user]) => [index, user]
      );
      yield output(createUserInsertions, ([index, user]) => {
        internalTable.splice(index, 0, user);
      });
      const createdUsers = merge(createUserInsertions, signups);
      const changePasswordInsertions = filter(
        insertions,
        x => x[0] === "changePassword"
      );
      const passwordChanges = map(
        changePasswordInsertions,
        ([, index, password]) => ({
          index,
          username: internalTable[index].username,
          password
        })
      );
      yield output(
        passwordChanges,
        ({ index, password }) => (internalTable[index].password = password)
      );
      const removedUsers = map(usernamesToRemove, username => ({
        index: findUsername(username),
        username
      }));
      yield output(removedUsers, ({ index }) => internalTable.splice(index, 1));
      clears = filter(clears, _ => internalTable.length !== 0);
      yield output(clears, _ => (internalTable = []));

      const tryLogins = event =>
        map(event, ({ username, password }) => {
          const foundUser = internalTable[findUsername(username)];
          return (
            foundUser !== undefined &&
            foundUser.username === username &&
            foundUser.password === password
          );
        });
      return {
        createdUsers,
        passwordChanges,
        removedUsers,
        clears,
        tryLogins,
        signups
      };
    }

    const nodeBuilder = (constructor, modifiers) => {
      const fromImpureBuilder = impureBuild => {
        const builder = (...children) =>
          fromImpureBuilder(varsOut => {
            const node = impureBuild(varsOut);
            // Use append instead of appendChild because we need to handle text nodes
            node.append(...children.map(child => child._impureBuild(varsOut)));
            return node;
          });
        for (const [key, modifier] of Object.entries(modifiers)) {
          builder[key] = (...args) =>
            fromImpureBuilder(varsOut => {
              const node = impureBuild(varsOut);
              modifier(...args)(node);
              return node;
            });
        }
        builder._impureBuild = impureBuild;
        builder.build = _ => {
          const varsOut = {};
          varsOut.root = impureBuild(varsOut);
          return varsOut;
        };
        builder.var = name =>
          fromImpureBuilder(varsOut => {
            const node = impureBuild(varsOut);
            varsOut[name] = node;
            return node;
          });
        return builder;
      };
      return fromImpureBuilder(constructor);
    };
    const div = nodeBuilder(_ => document.createElement("div"), {});
    const button = nodeBuilder(_ => document.createElement("button"), {
      textContent: textContent => node => (node.textContent = textContent)
    });
    const textInput = nodeBuilder(_ => {
      const node = document.createElement("input");
      node.type = "text";
      return node;
    }, {});
    const p = nodeBuilder(_ => document.createElement("p"), {});
    const table = nodeBuilder(_ => document.createElement("table"), {});
    const thead = nodeBuilder(_ => document.createElement("thead"), {});
    const tbody = nodeBuilder(_ => document.createElement("tbody"), {});
    const tr = nodeBuilder(_ => document.createElement("tr"), {});
    const th = nodeBuilder(_ => document.createElement("th"), {
      textContent: textContent => node => (node.textContent = textContent)
    });
    const td = nodeBuilder(_ => document.createElement("td"), {
      textContent: textContent => node => (node.textContent = textContent)
    });
    const text = string => ({
      _impureBuild: _ => string
    });

    function* userTable(signupAttempts) {
      const {
        root: userTableDiv,
        clearButton,
        userTable,
        usernameInsertInput,
        passwordInsertInput,
        insertButton,
        userTableBody
      } = div(
        button.var("clearButton").textContent("Clear"),
        table.var("userTable")(
          thead(
            tr(th.textContent("Username"), th.textContent("Password")),
            tr(
              td(textInput.var("usernameInsertInput")),
              td(textInput.var("passwordInsertInput")),
              td(button.var("insertButton").textContent("Insert"))
            )
          ),
          tbody.var("userTableBody")
        )
      ).build();

      const insertions = filter(
        mapTag(
          tag(getClicks(insertButton), getInputValues(usernameInsertInput)),
          getInputValues(passwordInsertInput),
          (username, password) => ({
            username,
            password
          })
        ),
        ({ username, password }) => username !== "" && password !== ""
      );

      const usernamesToRemove = eventLoop();

      const {
        createdUsers,
        passwordChanges,
        removedUsers,
        clears,
        tryLogins
      } = yield* userDatabase({
        insertions,
        usernamesToRemove,
        clears: getClicks(clearButton),
        signupAttempts
      });

      yield output(insertions, () => {
        usernameInsertInput.value = "";
        passwordInsertInput.value = "";
      });

      // TODO make pure
      usernamesToRemove.loop(
        yield* mergeBind(createdUsers, ([index, user]) => {
          const { root: rowElement, xButton } = tr(
            td.textContent(user.username),
            td.textContent(user.password),
            td(button.var("xButton").textContent("X"))
          ).build();
          if (index === userTableBody.children.length) {
            userTableBody.appendChild(rowElement);
          } else {
            userTableBody.insertBefore(
              rowElement,
              userTableBody.children[index]
            );
          }
          return getClicks(xButton).map(_ => user.username);
        })
      );

      yield output(passwordChanges, ({ index, password }) => {
        const rowElement = userTableBody.children[index];
        rowElement.children[1].textContent = password;
      });

      yield output(removedUsers, ({ index }) =>
        userTableBody.children[index].remove()
      );

      yield output(clears, _ => (userTableBody.innerHTML = ""));

      return { userTableDiv, passwordChanges, removedUsers, clears, tryLogins };
    }

    // Pull monad
    function* main() {
      const signupAttempts = eventLoop();

      //div(yield* userTable(signupAttempts).var("userTable"), slot(loginDiv))
      const {
        userTableDiv,
        passwordChanges,
        removedUsers,
        clears,
        tryLogins
      } = yield* userTable(signupAttempts);
      document.body.appendChild(userTableDiv);
      document.body.appendChild(document.createElement("p"));

      function* createLoginDiv() {
        const {
          root,
          usernameInput,
          passwordInput,
          loginButton,
          statusText,
          signupButton
        } = div(
          text("Username:"),
          textInput.var("usernameInput"),
          text("Password:"),
          textInput.var("passwordInput"),
          button.var("loginButton").textContent("Login"),
          p.var("statusText"),
          text("Don't have an account yet?"),
          button.var("signupButton").textContent("Signup")
        ).build();

        let loginAttempts = mapTag(
          tag(getClicks(loginButton), getInputValues(usernameInput)),
          getInputValues(passwordInput),
          (username, password) => ({
            username,
            password
          })
        );
        yield output(
          filter(loginAttempts, ({ username }) => username === ""),
          () => (statusText.textContent = "Username required!")
        );
        yield output(
          filter(
            loginAttempts,
            ({ username, password }) => username !== "" && password === ""
          ),
          () => (statusText.textContent = "Password required!")
        );
        loginAttempts = tryLogins(
          filter(
            loginAttempts,
            ({ username, password }) => username !== "" && password !== ""
          )
        );
        yield output(
          filter(loginAttempts, success => !success),
          () => (statusText.textContent = `Invalid login!`)
        );

        return [
          root,
          merge(
            map(getClicks(signupButton), () => createSignupDiv),
            map(
              tag(
                filter(loginAttempts, success => success),
                getInputValues(usernameInput)
              ),
              () => createLoggedInDiv
            )
          ),
          never
        ];
      }

      const createSignupDiv = _ => {
        const {
          root,
          usernameInput,
          passwordInput,
          signupButton,
          statusText,
          loginButton
        } = div(
          text("Username:"),
          textInput.var("usernameInput"),
          text("Password:"),
          textInput.var("passwordInput"),
          button.var("signupButton").textContent("Signup"),
          p.var("statusText"),
          text("Already have an account?"),
          button.var("loginButton").textContent("Login")
        ).build();

        const signupAttempts = getClicks(signupButton)
          .tag(getInputValues(usernameInput))
          .mapTag(getInputValues(passwordInput), (username, password) => ({
            username,
            password
          }));
        signupAttempts
          .filter(({ username }) => username === "")
          .map(_ => (statusText.textContent = "Username required!"));
        signupAttempts
          .filter(
            ({ username, password }) => username !== "" && password === ""
          )
          .map(_ => (statusText.textContent = "Password required!"));

        return [
          root,
          getClicks(loginButton).map(createLoginDiv),
          signupAttempts.filter(
            ({ username, password }) => username !== "" && password !== ""
          )
        ];
      };

      const createLoggedInDiv = username => {
        const { root: loggedInDiv, logoutButton } = div(
          text(`Hello ${username}`),
          button.var("logoutButton").textContent("Logout")
        ).build();

        return [
          loggedInDiv,
          getClicks(logoutButton)
            .merge(
              passwordChanges
                .merge(removedUsers)
                .filter(x => x.username === username)
            )
            .merge(clears)
            .map(createLoginDiv),
          never
        ];
      };

      let publishStartPage;
      const startPage = input(p => (publishStartPage = p));
      const start = _ => publishStartPage(createLoginDiv);

      const authPages = eventLoop();
      const appPages = observeE(merge(authPages, startPage));
      
      yield output(appPages, ([appDiv, ,]) => {
        document.body.lastElementChild.remove();
        document.body.appendChild(appDiv);
      });

      signupAttempts.loop(
        yield* switchE(map(appPages, ([, , signupAttempts]) => signupAttempts))
      );
      authPages.loop(
        yield* switchE(map(appPages, ([, nextAuthPage]) => nextAuthPage))
      );

      return start;
    }

    runMonad(new Moment.Context(), main())();
  </script>
</html>
